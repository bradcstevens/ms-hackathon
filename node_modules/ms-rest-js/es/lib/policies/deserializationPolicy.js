// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
import * as tslib_1 from "tslib";
import * as xml2js from "isomorphic-xml2js";
import { RestError } from "../restError";
import { MapperType } from "../serializer";
import * as utils from "../util/utils";
import { BaseRequestPolicy } from "./requestPolicy";
/**
 * Create a new serialization RequestPolicyCreator that will serialized HTTP request bodies as they
 * pass through the HTTP pipeline.
 */
export function deserializationPolicy() {
    return function (nextPolicy, options) {
        return new DeserializationPolicy(nextPolicy, options);
    };
}
/**
 * A RequestPolicy that will deserialize HTTP response bodies and headers as they pass through the
 * HTTP pipeline.
 */
var DeserializationPolicy = /** @class */ (function (_super) {
    tslib_1.__extends(DeserializationPolicy, _super);
    function DeserializationPolicy(nextPolicy, options) {
        return _super.call(this, nextPolicy, options) || this;
    }
    DeserializationPolicy.prototype.sendRequest = function (request) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._nextPolicy.sendRequest(request).then(deserializeResponseBody)];
            });
        });
    };
    return DeserializationPolicy;
}(BaseRequestPolicy));
export { DeserializationPolicy };
function deserializeResponseBody(response) {
    return parse(response).then(function (response) {
        var operationSpec = response.request.operationSpec;
        if (operationSpec && operationSpec.responses) {
            var statusCode = response.status;
            var expectedStatusCodes = Object.keys(operationSpec.responses);
            var hasNoExpectedStatusCodes = (expectedStatusCodes.length === 0 || (expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default"));
            var responseSpec = operationSpec.responses[statusCode];
            var isExpectedStatusCode = hasNoExpectedStatusCodes ? (200 <= statusCode && statusCode < 300) : !!responseSpec;
            if (!isExpectedStatusCode) {
                var defaultResponseSpec = operationSpec.responses.default;
                if (defaultResponseSpec) {
                    var initialErrorMessage = isStreamOperation(operationSpec.responses)
                        ? "Unexpected status code: " + statusCode
                        : response.bodyAsText;
                    var error = new RestError(initialErrorMessage);
                    error.statusCode = statusCode;
                    error.request = utils.stripRequest(response.request);
                    error.response = utils.stripResponse(response);
                    var parsedErrorResponse = response.parsedBody;
                    try {
                        if (parsedErrorResponse) {
                            var defaultResponseBodyMapper = defaultResponseSpec.bodyMapper;
                            if (defaultResponseBodyMapper && defaultResponseBodyMapper.serializedName === "CloudError") {
                                if (parsedErrorResponse.error) {
                                    parsedErrorResponse = parsedErrorResponse.error;
                                }
                                if (parsedErrorResponse.code) {
                                    error.code = parsedErrorResponse.code;
                                }
                                if (parsedErrorResponse.message) {
                                    error.message = parsedErrorResponse.message;
                                }
                            }
                            else {
                                var internalError = parsedErrorResponse;
                                if (parsedErrorResponse.error) {
                                    internalError = parsedErrorResponse.error;
                                }
                                error.code = internalError.code;
                                if (internalError.message) {
                                    error.message = internalError.message;
                                }
                            }
                            if (defaultResponseBodyMapper) {
                                var valueToDeserialize = parsedErrorResponse;
                                if (operationSpec.isXML && defaultResponseBodyMapper.type.name === MapperType.Sequence) {
                                    valueToDeserialize = typeof parsedErrorResponse === "object"
                                        ? parsedErrorResponse[defaultResponseBodyMapper.xmlElementName]
                                        : [];
                                }
                                error.body = operationSpec.serializer.deserialize(defaultResponseBodyMapper, valueToDeserialize, "error.body");
                            }
                        }
                    }
                    catch (defaultError) {
                        error.message = "Error \"" + defaultError.message + "\" occurred in deserializing the responseBody - \"" + response.bodyAsText + "\" for the default response.";
                    }
                    return Promise.reject(error);
                }
            }
            else if (responseSpec) {
                if (responseSpec.bodyMapper) {
                    var valueToDeserialize = response.parsedBody;
                    if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperType.Sequence) {
                        valueToDeserialize = typeof valueToDeserialize === "object" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];
                    }
                    try {
                        response.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody");
                    }
                    catch (error) {
                        var restError = new RestError("Error " + error + " occurred in deserializing the responseBody - " + response.bodyAsText);
                        restError.request = utils.stripRequest(response.request);
                        restError.response = utils.stripResponse(response);
                        return Promise.reject(restError);
                    }
                }
                if (responseSpec.headersMapper) {
                    response.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, response.headers.rawHeaders(), "operationRes.parsedHeaders");
                }
            }
        }
        return Promise.resolve(response);
    });
}
function isStreamOperation(responseSpecs) {
    var result = false;
    for (var statusCode in responseSpecs) {
        var operationResponse = responseSpecs[statusCode];
        if (operationResponse.bodyMapper && operationResponse.bodyMapper.type.name === MapperType.Stream) {
            result = true;
            break;
        }
    }
    return result;
}
function parse(operationResponse) {
    var errorHandler = function (err) {
        var msg = "Error \"" + err + "\" occurred while parsing the response body - " + operationResponse.bodyAsText + ".";
        var errCode = err.code || "PARSE_ERROR";
        var e = new RestError(msg, errCode, operationResponse.status, operationResponse.request, operationResponse, operationResponse.bodyAsText);
        return Promise.reject(e);
    };
    if (!operationResponse.request.rawResponse && operationResponse.bodyAsText) {
        var text_1 = operationResponse.bodyAsText;
        var contentType = operationResponse.headers.get("Content-Type") || "";
        var contentComponents = contentType.split(";").map(function (component) { return component.toLowerCase(); });
        if (contentComponents.some(function (component) { return component === "application/xml" || component === "text/xml"; })) {
            var xmlParser_1 = new xml2js.Parser({
                explicitArray: false,
                explicitCharkey: false,
                explicitRoot: false
            });
            return new Promise(function (resolve, reject) {
                xmlParser_1.parseString(text_1, function (err, result) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        operationResponse.parsedBody = result;
                        resolve(operationResponse);
                    }
                });
            }).catch(errorHandler);
        }
        else if (contentComponents.some(function (component) { return component === "application/json" || component === "text/json"; }) || !contentType) {
            return new Promise(function (resolve) {
                operationResponse.parsedBody = JSON.parse(text_1);
                resolve(operationResponse);
            }).catch(errorHandler);
        }
    }
    return Promise.resolve(operationResponse);
}
//# sourceMappingURL=deserializationPolicy.js.map